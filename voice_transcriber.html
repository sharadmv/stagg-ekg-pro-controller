<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gemini Live Transcriber (2.5 Flash)</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            max-width: 900px;
            margin: 2rem auto;
            padding: 0 1rem;
            line-height: 1.5;
            background-color: #0f172a;
            color: #f8fafc;
        }
        .container {
            background: #1e293b;
            padding: 2rem;
            border-radius: 16px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.3);
            border: 1px solid #334155;
        }
        h1 { margin-top: 0; color: #38bdf8; font-size: 1.75rem; text-align: center; }
        .form-group { margin-bottom: 1.25rem; }
        label { display: block; margin-bottom: 0.5rem; font-weight: 600; color: #94a3b8; }
        input[type="password"], select {
            width: 100%;
            padding: 0.75rem;
            border: 1px solid #334155;
            border-radius: 8px;
            box-sizing: border-box;
            font-size: 1rem;
            background: #0f172a;
            color: white;
        }
        .controls {
            display: flex;
            gap: 1rem;
            align-items: center;
            justify-content: center;
            margin-bottom: 1.5rem;
        }
        button {
            padding: 0.75rem 2rem;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            font-size: 1rem;
            transition: all 0.2s;
        }
        #connectBtn { background-color: #38bdf8; color: #0f172a; }
        #connectBtn.connected { background-color: #ef4444; color: white; }
        #connectBtn:disabled { background-color: #475569; cursor: not-allowed; }
        
        #visualizer-container {
            display: flex;
            justify-content: center;
            margin: 1.5rem 0;
            position: relative;
        }
        #visualizer {
            width: 250px;
            height: 250px;
            border-radius: 50%;
            background: #0f172a;
        }

        #status { font-size: 0.9rem; color: #94a3b8; display: flex; align-items: center; gap: 0.5rem; }
        .dot { height: 10px; width: 10px; border-radius: 50%; display: inline-block; background-color: #475569; }
        .dot.active { background-color: #10b981; box-shadow: 0 0 10px #10b981; animation: pulse 1.5s infinite; }
        
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.4; }
            100% { opacity: 1; }
        }

        #transcript {
            width: 100%;
            height: 200px;
            padding: 1rem;
            border: 1px solid #334155;
            border-radius: 8px;
            box-sizing: border-box;
            background: #0f172a;
            white-space: pre-wrap;
            overflow-y: auto;
            font-size: 1.1rem;
            color: #e2e8f0;
        }
        .error { color: #f87171; font-weight: bold; }
        .system-msg { color: #64748b; font-style: italic; font-size: 0.9rem; }
    </style>
</head>
<body>

<div class="container">
    <h1>Gemini Live 2.5</h1>
    
    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem;">
        <div class="form-group">
            <label for="apiKey">Gemini API Key</label>
            <input type="password" id="apiKey" placeholder="Enter API key">
        </div>
        <div class="form-group">
            <label for="voiceSelect">Voice</label>
            <select id="voiceSelect">
                <option value="Puck">Puck</option>
                <option value="Charon">Charon</option>
                <option value="Kore">Kore</option>
                <option value="Fenrir">Fenrir</option>
                <option value="Aoede">Aoede</option>
            </select>
        </div>
    </div>

    <div id="visualizer-container">
        <canvas id="visualizer"></canvas>
    </div>

    <div class="controls">
        <button id="connectBtn">Connect Live</button>
        <div id="status">
            <span id="statusDot" class="dot"></span>
            <span id="statusText">Disconnected</span>
        </div>
    </div>

    <div class="form-group">
        <label>Live Conversation</label>
        <div id="transcript">Ready to connect...</div>
    </div>
</div>

<script>
    const connectBtn = document.getElementById('connectBtn');
    const statusText = document.getElementById('statusText');
    const statusDot = document.getElementById('statusDot');
    const transcriptDiv = document.getElementById('transcript');
    const apiKeyInput = document.getElementById('apiKey');
    const voiceSelect = document.getElementById('voiceSelect');
    const canvas = document.getElementById('visualizer');
    const ctx = canvas.getContext('2d');

    let ws = null;
    let audioContext = null;
    let audioWorkletNode = null;
    let source = null;
    let analyser = null;
    let nextStartTime = 0;
    let animationId = null;

    // Set canvas resolution
    canvas.width = 500;
    canvas.height = 500;

    const workletCode = `
    class RecorderProcessor extends AudioWorkletProcessor {
        process(inputs, outputs, parameters) {
            const input = inputs[0];
            if (input && input.length > 0) {
                const float32Array = input[0];
                const int16Array = new Int16Array(float32Array.length);
                for (let i = 0; i < float32Array.length; i++) {
                    const s = Math.max(-1, Math.min(1, float32Array[i]));
                    int16Array[i] = s < 0 ? s * 0x8000 : s * 0x7FFF;
                }
                this.port.postMessage(int16Array.buffer, [int16Array.buffer]);
            }
            return true;
        }
    }
    registerProcessor('recorder-processor', RecorderProcessor);
    `;

    connectBtn.addEventListener('click', async () => {
        if (ws) {
            disconnect();
            return;
        }
        const apiKey = apiKeyInput.value.trim();
        if (!apiKey) return alert('Please enter your Gemini API key.');

        try {
            // Initialize AudioContext here on user click
            audioContext = new AudioContext({ sampleRate: 16000 });
            if (audioContext.state === 'suspended') {
                await audioContext.resume();
            }
            startLiveSession(apiKey);
        } catch (err) {
            console.error("Failed to initialize audio:", err);
            alert("Microphone access denied or audio error.");
        }
    });

    async function startLiveSession(apiKey) {
        statusText.textContent = 'Connecting...';
        transcriptDiv.textContent = '';
        nextStartTime = 0;
        
        const url = `wss://generativelanguage.googleapis.com/ws/google.ai.generativelanguage.v1alpha.GenerativeService.BidiGenerateContent?key=${apiKey}`;
        ws = new WebSocket(url);

        ws.onmessage = async (event) => {
            let data = event.data;
            if (data instanceof Blob) data = await data.text();
            else if (data instanceof ArrayBuffer) data = new TextDecoder().decode(data);

            try {
                const response = JSON.parse(data);
                if (response.serverContent) {
                    const modelTurn = response.serverContent.modelTurn;
                    if (modelTurn && modelTurn.parts) {
                        for (const part of modelTurn.parts) {
                            if (part.text) appendMessage(part.text);
                            const inlineData = part.inline_data || part.inlineData;
                            if (inlineData && inlineData.data) playReceivedAudio(inlineData.data);
                        }
                    }
                    if (response.serverContent.interrupted) {
                        appendMessage('System: Interrupted', 'system-msg');
                        nextStartTime = 0;
                    }
                }
                if (response.error) {
                    appendMessage(`Error: ${response.error.message}`, 'error');
                    disconnect();
                }
            } catch (e) { console.error("Parse error", e); }
        };

        ws.onopen = async () => {
            statusText.textContent = 'Connected';
            statusDot.classList.add('active');
            connectBtn.textContent = 'Disconnect';
            connectBtn.classList.add('connected');
            
            await initAudio();
            startVisualizer();

            const setupMsg = {
                setup: {
                    model: "models/gemini-2.5-flash-native-audio-preview-09-2025",
                    generation_config: {
                        response_modalities: ["audio"],
                        speech_config: {
                            voice_config: { prebuilt_voice_config: { voice_name: voiceSelect.value } }
                        }
                    }
                }
            };
            ws.send(JSON.stringify(setupMsg));
            appendMessage('System: Session started.', 'system-msg');
        };

        ws.onclose = () => disconnect();
        ws.onerror = () => disconnect();
    }

    async function initAudio() {
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        source = audioContext.createMediaStreamSource(stream);

        // Setup Analyser
        analyser = audioContext.createAnalyser();
        analyser.fftSize = 256;
        
        const blob = new Blob([workletCode], { type: 'application/javascript' });
        const workletUrl = URL.createObjectURL(blob);
        await audioContext.audioWorklet.addModule(workletUrl);
        
        audioWorkletNode = new AudioWorkletNode(audioContext, 'recorder-processor');
        audioWorkletNode.port.onmessage = (event) => {
            if (ws && ws.readyState === WebSocket.OPEN) {
                const base64Data = btoa(String.fromCharCode(...new Uint8Array(event.data)));
                ws.send(JSON.stringify({
                    realtime_input: { media_chunks: [{ mime_type: "audio/pcm;rate=16000", data: base64Data }] }
                }));
            }
        };

        source.connect(audioWorkletNode);
    }

    function playReceivedAudio(base64Data) {
        if (!audioContext) return;
        if (audioContext.state === 'suspended') audioContext.resume();

        const binaryString = atob(base64Data);
        const bytes = new Uint8Array(binaryString.length);
        for (let i = 0; i < binaryString.length; i++) bytes[i] = binaryString.charCodeAt(i);
        
        const pcm16 = new Int16Array(bytes.buffer.byteLength % 2 === 0 ? bytes.buffer : bytes.buffer.slice(0, -1));
        const float32 = new Float32Array(pcm16.length);
        for (let i = 0; i < pcm16.length; i++) float32[i] = pcm16[i] / 32768.0;

        const buffer = audioContext.createBuffer(1, float32.length, 24000);
        buffer.getChannelData(0).set(float32);

        const sourceNode = audioContext.createBufferSource();
        sourceNode.buffer = buffer;
        
        // Connect to Analyser then to Destination
        sourceNode.connect(analyser);
        analyser.connect(audioContext.destination);

        const startTime = Math.max(nextStartTime, audioContext.currentTime);
        sourceNode.start(startTime);
        nextStartTime = startTime + buffer.duration;
    }

    function startVisualizer() {
        const bufferLength = analyser.frequencyBinCount;
        const dataArray = new Uint8Array(bufferLength);

        function draw() {
            animationId = requestAnimationFrame(draw);
            analyser.getByteFrequencyData(dataArray);

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const radius = 100;

            // Draw center circle
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius - 10, 0, 2 * Math.PI);
            ctx.fillStyle = '#0f172a';
            ctx.fill();
            ctx.strokeStyle = '#38bdf8';
            ctx.lineWidth = 2;
            ctx.stroke();

            // Draw bars in a circle
            for (let i = 0; i < bufferLength; i++) {
                const barHeight = (dataArray[i] / 255) * 100;
                const angle = (i / bufferLength) * 2 * Math.PI;
                
                const x1 = centerX + Math.cos(angle) * radius;
                const y1 = centerY + Math.sin(angle) * radius;
                const x2 = centerX + Math.cos(angle) * (radius + barHeight);
                const y2 = centerY + Math.sin(angle) * (radius + barHeight);

                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.strokeStyle = `hsl(${(i / bufferLength) * 360}, 70%, 60%)`;
                ctx.lineWidth = 4;
                ctx.lineCap = 'round';
                ctx.stroke();
            }
        }
        draw();
    }

    function disconnect() {
        if (ws) ws.close();
        ws = null;
        if (audioContext) audioContext.close();
        audioContext = null;
        if (animationId) cancelAnimationFrame(animationId);
        statusText.textContent = 'Disconnected';
        statusDot.classList.remove('active');
        connectBtn.textContent = 'Connect Live';
        connectBtn.classList.remove('connected');
        appendMessage('System: Session ended.', 'system-msg');
        ctx.clearRect(0, 0, canvas.width, canvas.height);
    }

    function appendMessage(text, className = '') {
        const span = document.createElement('span');
        if (className) span.className = className;
        span.textContent = text + (className === 'system-msg' ? '\n' : ' ');
        transcriptDiv.appendChild(span);
        transcriptDiv.scrollTop = transcriptDiv.scrollHeight;
    }
</script>

</body>
</html>